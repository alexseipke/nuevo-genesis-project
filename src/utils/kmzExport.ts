import JSZip from 'jszip';
import { Waypoint, MissionParameters } from '@/types/mission';

export function exportToKMZ(waypoints: Waypoint[], parameters: MissionParameters): Promise<Blob> {
  return new Promise((resolve, reject) => {
    try {
      const zip = new JSZip();
      
      // Crear el contenido KML
      const kmlContent = generateKML(waypoints, parameters);
      
      // Añadir el archivo KML al ZIP
      zip.file('mission.kml', kmlContent);
      
      // Generar el archivo KMZ (ZIP)
      zip.generateAsync({ type: 'blob' })
        .then(blob => resolve(blob))
        .catch(error => reject(error));
    } catch (error) {
      reject(error);
    }
  });
}

function generateKML(waypoints: Waypoint[], parameters: MissionParameters): string {
  const centerCoords = parameters.center;
  const poiCoords = parameters.poiLocation;
  
  // Calcular altitudes relativas al punto de despegue (primer waypoint)
  const takeoffAltitude = waypoints.length > 0 ? waypoints[0].altitude : parameters.initialAltitude;
  
  let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">
  <Document>
    <name>Viizor UAV Mission</name>
    <description>Mission generated by Viizor - UAV Mission Planner</description>
    
    <!-- Estilos -->
    <Style id="waypointStyle">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>0.8</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="photoWaypointStyle">
      <IconStyle>
        <color>ff7700ff</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/camera.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="centerStyle">
      <IconStyle>
        <color>ffff0000</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/target.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="orbitLineStyle">
      <LineStyle>
        <color>7f0000ff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    
    <!-- Centro de Órbita -->`;

  if (centerCoords) {
    kml += `
    <Placemark>
      <name>Centro de Órbita</name>
      <description>Centro de la órbita de la misión</description>
      <styleUrl>#centerStyle</styleUrl>
      <Point>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>${centerCoords.lng},${centerCoords.lat},${parameters.initialAltitude - takeoffAltitude}</coordinates>
      </Point>
    </Placemark>`;
  }

  // Point of Interest
  if (poiCoords) {
    kml += `
    <Placemark>
      <name>Point of Interest</name>
      <description>Objetivo de las fotografías</description>
      <styleUrl>#centerStyle</styleUrl>
      <Point>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>${poiCoords.lng},${poiCoords.lat},${parameters.poiInitialAltitude - takeoffAltitude}</coordinates>
      </Point>
    </Placemark>`;
  }

  // Waypoints
  waypoints.forEach((waypoint) => {
    const style = waypoint.takePhoto ? 'photoWaypointStyle' : 'waypointStyle';
    const name = waypoint.takePhoto ? 'Foto' : 'Waypoint';
    
    kml += `
    <Placemark>
      <name>${name} ${waypoint.id}</name>
      <description>
        Altitud: ${waypoint.altitude.toFixed(1)}m&lt;br/&gt;
        Heading: ${waypoint.heading.toFixed(1)}°&lt;br/&gt;
        Velocidad: ${waypoint.speed.toFixed(1)}m/s&lt;br/&gt;
        ${waypoint.takePhoto ? 'Punto de fotografía' : 'Waypoint de navegación'}
      </description>
      <styleUrl>#${style}</styleUrl>
      <Point>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>${waypoint.longitude},${waypoint.latitude},${waypoint.altitude - takeoffAltitude}</coordinates>
      </Point>
    </Placemark>`;
  });

  // Línea de la órbita
  if (waypoints.length > 1) {
    kml += `
    <Placemark>
      <name>Ruta de Vuelo</name>
      <description>Trayectoria completa de la misión</description>
      <styleUrl>#orbitLineStyle</styleUrl>
      <LineString>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>`;
    
    waypoints.forEach((waypoint) => {
      kml += `${waypoint.longitude},${waypoint.latitude},${waypoint.altitude - takeoffAltitude} `;
    });
    
    kml += `</coordinates>
      </LineString>
    </Placemark>`;
  }

  // Círculos de radio inicial y final
  if (centerCoords) {
    // Radio inicial
    kml += `
    <Placemark>
      <name>Radio Inicial (${parameters.initialRadius}m)</name>
      <description>Radio inicial de la órbita</description>
      <styleUrl>#orbitLineStyle</styleUrl>
      <Polygon>
        <altitudeMode>relativeToGround</altitudeMode>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>`;
    
    const initialCircle = generateCircleCoordinates(centerCoords, parameters.initialRadius, parameters.initialAltitude - takeoffAltitude);
    kml += initialCircle.map(coord => `${coord.lng},${coord.lat},${coord.alt}`).join(' ');
    
    kml += `</coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>`;

    // Radio final si es diferente
    if (parameters.finalRadius !== parameters.initialRadius) {
      kml += `
      <Placemark>
        <name>Radio Final (${parameters.finalRadius}m)</name>
        <description>Radio final de la órbita</description>
        <styleUrl>#orbitLineStyle</styleUrl>
        <Polygon>
          <altitudeMode>relativeToGround</altitudeMode>
          <outerBoundaryIs>
            <LinearRing>
              <coordinates>`;
        
        const finalCircle = generateCircleCoordinates(centerCoords, parameters.finalRadius, parameters.finalAltitude - takeoffAltitude);
        kml += finalCircle.map(coord => `${coord.lng},${coord.lat},${coord.alt}`).join(' ');
      
      kml += `</coordinates>
            </LinearRing>
          </outerBoundaryIs>
        </Polygon>
      </Placemark>`;
    }
  }

  kml += `
  </Document>
</kml>`;

  return kml;
}

function generateCircleCoordinates(
  center: { lat: number; lng: number }, 
  radiusInMeters: number, 
  altitude: number
): { lat: number; lng: number; alt: number }[] {
  const points = 32;
  const coordinates = [];
  
  const lat = center.lat * Math.PI / 180;
  const lng = center.lng * Math.PI / 180;
  
  for (let i = 0; i <= points; i++) {
    const bearing = (i / points) * 2 * Math.PI;
    
    // Convertir metros a grados aproximadamente
    const deltaLat = (radiusInMeters / 111000) * Math.cos(bearing);
    const deltaLng = (radiusInMeters / (111000 * Math.cos(lat))) * Math.sin(bearing);
    
    const pointLat = (lat + deltaLat) * 180 / Math.PI;
    const pointLng = (lng + deltaLng) * 180 / Math.PI;
    
    coordinates.push({
      lat: pointLat,
      lng: pointLng,
      alt: altitude
    });
  }
  
  return coordinates;
}